{"ast":null,"code":"import { createListMap } from '.';\nconst recurse = function (elements) {\n  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  !!elements && elements.map((element, e) => {\n    var _element$elements, _element$elements2;\n    const cdata = (_element$elements = element.elements) === null || _element$elements === void 0 ? void 0 : _element$elements.find(e => e.type === 'cdata');\n    const text = (_element$elements2 = element.elements) === null || _element$elements2 === void 0 ? void 0 : _element$elements2.find(e => e.type === 'text');\n    if (text) {\n      out.push({\n        [element.name]: text.text,\n        ...element.attributes,\n        level\n      });\n    } else if (cdata) {\n      out.push({\n        [element.name]: cdata.cdata,\n        ...element.attributes,\n        level\n      });\n    } else {\n      out.push({\n        ...element.attributes,\n        level\n      });\n      recurse(element.elements, out, ++level);\n    }\n    return out;\n  });\n  return out;\n};\nexport const parseRss = elements => {\n  const nodes = recurse(elements);\n  return createListMap(nodes);\n};","map":{"version":3,"names":["createListMap","recurse","elements","out","level","map","element","e","cdata","find","type","text","push","name","attributes","parseRss","nodes"],"sources":["/home/miltonejones/projects/state-cast/src/util/parseRss.js"],"sourcesContent":["import { createListMap } from '.';\r\n\r\nconst recurse = (elements, out = [], level = 0) => {\r\n  !!elements &&\r\n    elements.map((element, e) => {\r\n      const cdata = element.elements?.find((e) => e.type === 'cdata');\r\n      const text = element.elements?.find((e) => e.type === 'text');\r\n      if (text) {\r\n        out.push({\r\n          [element.name]: text.text,\r\n          ...element.attributes,\r\n          level,\r\n        });\r\n      } else if (cdata) {\r\n        out.push({\r\n          [element.name]: cdata.cdata,\r\n          ...element.attributes,\r\n          level,\r\n        });\r\n      } else {\r\n        out.push({\r\n          ...element.attributes,\r\n          level,\r\n        });\r\n        recurse(element.elements, out, ++level);\r\n      }\r\n\r\n      return out;\r\n    });\r\n\r\n  return out;\r\n};\r\n\r\nexport const parseRss = (elements) => {\r\n  const nodes = recurse(elements);\r\n  return createListMap(nodes);\r\n};\r\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,GAAG;AAEjC,MAAMC,OAAO,GAAG,UAACC,QAAQ,EAA0B;EAAA,IAAxBC,GAAG,uEAAG,EAAE;EAAA,IAAEC,KAAK,uEAAG,CAAC;EAC5C,CAAC,CAACF,QAAQ,IACRA,QAAQ,CAACG,GAAG,CAAC,CAACC,OAAO,EAAEC,CAAC,KAAK;IAAA;IAC3B,MAAMC,KAAK,wBAAGF,OAAO,CAACJ,QAAQ,sDAAhB,kBAAkBO,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,IAAI,KAAK,OAAO,CAAC;IAC/D,MAAMC,IAAI,yBAAGL,OAAO,CAACJ,QAAQ,uDAAhB,mBAAkBO,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,IAAI,KAAK,MAAM,CAAC;IAC7D,IAAIC,IAAI,EAAE;MACRR,GAAG,CAACS,IAAI,CAAC;QACP,CAACN,OAAO,CAACO,IAAI,GAAGF,IAAI,CAACA,IAAI;QACzB,GAAGL,OAAO,CAACQ,UAAU;QACrBV;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAII,KAAK,EAAE;MAChBL,GAAG,CAACS,IAAI,CAAC;QACP,CAACN,OAAO,CAACO,IAAI,GAAGL,KAAK,CAACA,KAAK;QAC3B,GAAGF,OAAO,CAACQ,UAAU;QACrBV;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACLD,GAAG,CAACS,IAAI,CAAC;QACP,GAAGN,OAAO,CAACQ,UAAU;QACrBV;MACF,CAAC,CAAC;MACFH,OAAO,CAACK,OAAO,CAACJ,QAAQ,EAAEC,GAAG,EAAE,EAAEC,KAAK,CAAC;IACzC;IAEA,OAAOD,GAAG;EACZ,CAAC,CAAC;EAEJ,OAAOA,GAAG;AACZ,CAAC;AAED,OAAO,MAAMY,QAAQ,GAAIb,QAAQ,IAAK;EACpC,MAAMc,KAAK,GAAGf,OAAO,CAACC,QAAQ,CAAC;EAC/B,OAAOF,aAAa,CAACgB,KAAK,CAAC;AAC7B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}