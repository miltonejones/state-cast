{"ast":null,"code":"import { __assign, __spreadArray, __read, __values } from './_virtual/_tslib.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { init, send as send$1, raise as raise$1, update, log as log$1, cancel as cancel$1, assign as assign$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nimport * as actionTypes from './actionTypes.js';\nexport { actionTypes };\nimport { toSCXMLEvent, isString, isFunction, toEventObject, getEventType, updateContext, flatten, isArray, toArray, toGuard, evaluateGuard, warn } from './utils.js';\nimport { IS_PRODUCTION } from './environment.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n  return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n  return {\n    type: raise$1,\n    event: event\n  };\n}\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\nfunction sendTo(actor, event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = \"\".concat(ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = \"\".concat(ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  if (!IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n    target = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, __spreadArray([], __read(args), false)) : originalTarget_1;\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n      return resolvedTarget;\n    };\n  }\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\nvar pluckAssigns = function (actionBlocks) {\n  var e_1, _a;\n  var assignActions = [];\n  try {\n    for (var actionBlocks_1 = __values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n      while (i < block.actions.length) {\n        if (block.actions[i].type === assign$1) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return assignActions;\n};\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n  function handleAction(blockType, actionObject) {\n    var _a;\n    switch (actionObject.type) {\n      case raise$1:\n        {\n          return resolveRaise(actionObject);\n        }\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number',\n          // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(actionObject.delay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n        if (predictableExec && sendAction.to !== SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n        return sendAction;\n      case log$1:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n          if (!matchedActions) {\n            return [];\n          }\n          var _b = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n              type: blockType,\n              actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n            }], predictableExec, preserveActionOrder), 2),\n            resolvedActionsFromChoose = _b[0],\n            resolvedContextFromChoose = _b[1];\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n          if (!matchedActions) {\n            return [];\n          }\n          var _c = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n              type: blockType,\n              actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n            }], predictableExec, preserveActionOrder), 2),\n            resolvedActionsFromPure = _c[0],\n            resolvedContext = _c[1];\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n      case stop$1:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n      case assign$1:\n        {\n          updatedContext = updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n          resolvedActionObject = __assign(__assign({}, resolvedActionObject), {\n            exec: function (_ctx) {\n              var args = [];\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n              exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));\n            }\n          });\n        }\n        return resolvedActionObject;\n    }\n  }\n  function processBlock(block) {\n    var e_2, _a;\n    var resolvedActions = [];\n    try {\n      for (var _b = __values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n  var resolvedActions = flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, isActionObject, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendTo, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };","map":{"version":3,"names":["__assign","__spreadArray","__read","__values","SpecialTargets","ActionTypes","init","send","send$1","raise","raise$1","update","log","log$1","cancel","cancel$1","assign","assign$1","error","error$1","stop","stop$1","pure","pure$1","choose","choose$1","actionTypes","toSCXMLEvent","isString","isFunction","toEventObject","getEventType","updateContext","flatten","isArray","toArray","toGuard","evaluateGuard","warn","IS_PRODUCTION","initEvent","type","getActionFunction","actionType","actionFunctionMap","undefined","toActionObject","action","actionObject","exec","name","toString","toActionObjects","actions","map","subAction","toActivityDefinition","id","event","to","Internal","resolveRaise","_event","options","delay","resolveSend","ctx","delaysMap","meta","resolvedEvent","data","resolvedDelay","configDelay","resolvedTarget","sendParent","Parent","sendTo","actor","sendUpdate","respond","_","__","_a","origin","defaultLogExpr","context","expr","label","resolveLog","value","sendId","start","activity","activityDef","Start","actorRef","Stop","resolveStop","actorRefOrString","resolvedActorRef","assignment","isActionObject","after","delayRef","idSuffix","concat","After","done","DoneState","eventObject","doneInvoke","DoneInvoke","ErrorPlatform","getActions","Pure","get","forwardTo","target","originalTarget_1","args","_i","arguments","length","apply","Error","escalate","errorData","conds","Choose","pluckAssigns","actionBlocks","e_1","assignActions","actionBlocks_1","actionBlocks_1_1","next","block","i","push","splice","e_1_1","return","call","resolveActions","machine","currentState","currentContext","predictableExec","preserveActionOrder","updatedContext","preservedContexts","deferredToBlockEnd","handleAction","blockType","sendAction","delays","resolved","chooseAction","matchedActions","find","condition","guard","cond","guards","_b","resolvedActionsFromChoose","resolvedContextFromChoose","_c","resolvedActionsFromPure","resolvedContext","resolvedActionObject","exec_1","contextIndex_1","_ctx","processBlock","e_2","resolvedActions","e_2_1","forEach"],"sources":["/home/miltonejones/projects/state-cast/node_modules/xstate/es/actions.js"],"sourcesContent":["import { __assign, __spreadArray, __read, __values } from './_virtual/_tslib.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { init, send as send$1, raise as raise$1, update, log as log$1, cancel as cancel$1, assign as assign$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nimport * as actionTypes from './actionTypes.js';\nexport { actionTypes };\nimport { toSCXMLEvent, isString, isFunction, toEventObject, getEventType, updateContext, flatten, isArray, toArray, toGuard, evaluateGuard, warn } from './utils.js';\nimport { IS_PRODUCTION } from './environment.js';\n\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n\n  return {\n    type: raise$1,\n    event: event\n  };\n}\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\nfunction sendTo(actor, event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = \"\".concat(ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = \"\".concat(ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  if (!IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n\n    target = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, __spreadArray([], __read(args), false)) : originalTarget_1;\n\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n\n      return resolvedTarget;\n    };\n  }\n\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nvar pluckAssigns = function (actionBlocks) {\n  var e_1, _a;\n\n  var assignActions = [];\n\n  try {\n    for (var actionBlocks_1 = __values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n\n      while (i < block.actions.length) {\n        if (block.actions[i].type === assign$1) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return assignActions;\n};\n\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n\n  function handleAction(blockType, actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        {\n          return resolveRaise(actionObject);\n        }\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(actionObject.delay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n\n        if (predictableExec && sendAction.to !== SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n\n        return sendAction;\n\n      case log$1:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _b = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromChoose = _b[0],\n              resolvedContextFromChoose = _b[1];\n\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _c = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromPure = _c[0],\n              resolvedContext = _c[1];\n\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n\n      case stop$1:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n\n      case assign$1:\n        {\n          updatedContext = updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n          resolvedActionObject = __assign(__assign({}, resolvedActionObject), {\n            exec: function (_ctx) {\n              var args = [];\n\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n\n              exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));\n            }\n          });\n        }\n\n        return resolvedActionObject;\n    }\n  }\n\n  function processBlock(block) {\n    var e_2, _a;\n\n    var resolvedActions = [];\n\n    try {\n      for (var _b = __values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n\n  var resolvedActions = flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, isActionObject, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendTo, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}